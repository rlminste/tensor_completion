
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Poblano Toolbox for MATLAB: Examples</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-25"><meta name="DC.source" content="examples_doc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

.background {
	background-color:#004889;
	background-image: url(images/banner-background.jpg);
	background-repeat:no-repeat;
}

  </style></head><body><div class="background"><a href="index.html"><img area="13494" src="images/logo.gif" alt="Sandia National Laboratories" border="0" height="78" width="173"></a></div><div class="content"><h1>Poblano Toolbox for MATLAB: Examples</h1><!--introduction--><p>This section describes the examples provided with Poblano. These examples can be used as templates for other function/gradient M-files.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Solving a Problem Using Poblano</a></li><li><a href="#4">Example 1: Multivariate Sum</a></li><li><a href="#11">Example 2: Matrix Decomposition</a></li><li><a href="#20">References</a></li></ul></div><p><hr></p><h2 id="2">Solving a Problem Using Poblano</h2><p>To solve a problem using Poblano, the following steps are performed:</p><div><ul><li><b>Step 1: Create M-file for objective and gradient.</b> An M-file which takes a vector as input and provides a scalar function value and gradient vector (the same size as the input) must be provided to the Poblano optimizers.</li><li><b>Step 2: Call the optimizer.</b> One of the Poblano optimizers is called, taking an anonymous function handle to the function to be minimized, a starting point, and an optional set of optimizer parameters as inputs.</li></ul></div><p>Poblano provides two example function/gradient M-files:</p><div><ul><li><tt>example1</tt>: simple multivariate function</li><li><tt>example2</tt>: more complicated function of a matrix variable</li></ul></div><p><hr></p><h2 id="4">Example 1: Multivariate Sum</h2><p>The following example is a simple multivariate function, <img src="examples_doc_eq11475201221685588019.png" alt="$f_1 : R^N \to R$" style="width:31px;height:6px;">, that can be minimized using Poblano:</p><p><img src="examples_doc_eq06327244962903926757.png" alt="$$f_1(x) = \sum_{n=1}^N \sin(ax_i)$$" style="width:47px;height:17px;"></p><p><img src="examples_doc_eq12534387414789875675.png" alt="$$\left(\nabla f_1(x)\right)_i = a \cos(ax_i)\; , \quad i=1,\dots,N$" style="width:92px;height:7px;"></p><p>where <img src="examples_doc_eq05508344529756732484.png" alt="$a$" style="width:3px;height:3px;"> is a scalar parameter.</p><p>Listed below are the contents of the <tt>example1.m</tt> M-file distributed with the Poblano code. This is an example of a self-contained function requiring a vector of independent variables and an <i>optional</i> scalar input parameter for <img src="examples_doc_eq05508344529756732484.png" alt="$a$" style="width:3px;height:3px;">.</p><pre>   function [f,g]=example1(x,a)
        if nargin &lt; 2, a = 1; end
        f = sum(sin(a*x));
        g = a*cos(a*x);</pre><p>The following presents a call to <tt>ncg</tt> optimizer using the default parameters (see <a href="B_ncg_docs.html">NCG method</a> documentation for more details) along with the information displayed and output return by Poblano. By default, at each iteration Poblano displays the number of function evaluations (<tt>FuncEvals</tt>), the function value at the current iterate (<tt>F(X)</tt>), and the Euclidean norm of the scaled gradient at the current iterate (|||G(X)||||||/N|, where <tt>N</tt> is the size of <tt>X</tt>) for each iteration. The output of Poblano optimizers is a Matlab structure containing the solution. See the <a href="A3_poblano_out_docs.html">Output Parameters</a> documentation for more details.</p><pre class="codeinput">out = ncg(@(x) example1(x,3), pi/4)
</pre><pre class="codeoutput"> Iter  FuncEvals       F(X)          ||G(X)||/N        
------ --------- ---------------- ----------------
     0         1       0.70710678       2.12132034
     1        14      -0.99998885       0.01416497
     2        16      -1.00000000       0.00000147

out = 

  struct with fields:

             Params: [1&times;1 inputParser]
           ExitFlag: 0
    ExitDescription: 'Successful termination based on StopTol'
                  X: 70.6858
                  F: -1.0000
                  G: -1.4734e-06
          FuncEvals: 16
              Iters: 2

</pre><p>The problem dimension, <img src="examples_doc_eq03672095713503266041.png" alt="$N$" style="width:5px;height:4px;">, of <tt>example1</tt> is determined by the size of the initial guess. For example, to solve a problem with <img src="examples_doc_eq11316155984473799093.png" alt="$N=10^6$" style="width:20px;height:5px;">, simply use an initial guess vector of size <img src="examples_doc_eq11316155984473799093.png" alt="$N=10^6$" style="width:20px;height:5px;"> when calling the Poblano optimizer:</p><pre class="codeinput">randn(<span class="string">'state'</span>,0);
x0 = randn(1e6,1);
out = ncg(@(x) example1(x,3), x0, <span class="string">'Display'</span>, <span class="string">'final'</span>)
</pre><pre class="codeoutput"> Iter  FuncEvals       F(X)          ||G(X)||/N        
------ --------- ---------------- ----------------
    15        60 -999993.22770173       0.00000649

out = 

  struct with fields:

             Params: [1&times;1 inputParser]
           ExitFlag: 0
    ExitDescription: 'Successful termination based on StopTol'
                  X: [1000000&times;1 double]
                  F: -9.9999e+05
                  G: [1000000&times;1 double]
          FuncEvals: 60
              Iters: 15

</pre><h2 id="11">Example 2: Matrix Decomposition</h2><p>The following example is a more complicated function involving matrix variables. As the Poblano methods require scalar functions with vector inputs, variable matrices must be reshaped into vectors first. The problem in this example is to find a rank-$k$ decomposition, <img src="examples_doc_eq05495199406804600545.png" alt="$UV^T$" style="width:12px;height:5px;">, of a <img src="examples_doc_eq03421469680577370400.png" alt="$m \times n$" style="width:15px;height:3px;"> matrix, <img src="examples_doc_eq05147331747641807187.png" alt="$A$" style="width:4px;height:4px;">, which minimizes the Frobenius norm of the fit</p><p><img src="examples_doc_eq11638118408029626293.png" alt="$$f_2 = \frac12\| A - UV^T \|_F^2$$" style="width:48px;height:12px;"></p><p><img src="examples_doc_eq02978325375087395648.png" alt="$$\nabla_U f_2 = -(A-UV^T)V$$" style="width:56px;height:7px;"></p><p><img src="examples_doc_eq07741076879175499892.png" alt="$$\nabla_V f_2 = -(A-UV^T)^T U$$" style="width:59px;height:7px;"></p><p>where <img src="examples_doc_eq13029888333516263543.png" alt="$A \in R^{m \times n}$" style="width:24px;height:5px;"> is a matrix with rank <img src="examples_doc_eq17937321231062034804.png" alt="$\geq k$" style="width:9px;height:5px;">, <img src="examples_doc_eq00543772986039519777.png" alt="$U \in R^{m \times k}$" style="width:24px;height:5px;">, and <img src="examples_doc_eq02586487823804834451.png" alt="$V \in R^{n \times k}$" style="width:23px;height:5px;">. This problem can be solved using Poblano by providing an M-file that computes the function and gradient shown above but that takes <img src="examples_doc_eq02619125812656254059.png" alt="$U$" style="width:4px;height:4px;"> and <img src="examples_doc_eq02739270504201626537.png" alt="$V$" style="width:4px;height:4px;"> as input in vectorized form.</p><p>This problem can be solved using Poblano by providing an M-?le that computes the function and gradient shown above but that takes U and V as input in vectorized form.</p><p>Listed below are the contents of the <tt>example2.m</tt> M-file distributed with the Poblano code. Note that the input <tt>Data</tt> is required and is a structure containing the matrix to be decomposed, <img src="examples_doc_eq05147331747641807187.png" alt="$A$" style="width:4px;height:4px;">, and the desired rank, <img src="examples_doc_eq15636846968047188835.png" alt="$k$" style="width:3px;height:5px;">. This example also illustrates how the vectorized form of the factor matrices, <img src="examples_doc_eq02619125812656254059.png" alt="$U$" style="width:4px;height:4px;"> and <img src="examples_doc_eq02739270504201626537.png" alt="$V$" style="width:4px;height:4px;">, are converted to matrix form for the function and gradient computations.</p><pre>   function [f,g]=example2(x,Data)
        % Data setup
        [m,n] = size(Data.A);
        k = Data.rank;
        U = reshape(x(1:m*k),m,k);
        V = reshape(x(m*k+1:m*k+n*k),n,k);</pre><pre>        % Function value (residual)
        AmUVt = Data.A-U*V';
        f = 0.5*norm(AmUVt,'fro')^2;</pre><pre>        % First derivatives computed in matrix form
        g = zeros((m+n)*k,1);
        g(1:m*k) = -reshape(AmUVt*V,m*k,1);
        g(m*k+1:end) = -reshape(AmUVt'*U,n*k,1);</pre><p>Included with Poblano are two helper functions and which can be used to generate problems instances along with starting points (<tt>example2_init.m</tt>) and extract the factors <img src="examples_doc_eq02619125812656254059.png" alt="$U$" style="width:4px;height:4px;"> and <img src="examples_doc_eq02739270504201626537.png" alt="$V$" style="width:4px;height:4px;"> from a solution vector (<tt>example2_extract.m</tt>). We show an example of their use below.</p><pre class="codeinput">randn(<span class="string">'state'</span>,0);
m = 4; n = 3; k = 2;
[x0,Data] = example2_init(m,n,k)
out = ncg(@(x) example2(x,Data), x0, <span class="string">'RelFuncTol'</span>, 1e-16, <span class="string">'StopTol'</span>, 1e-8, <span class="keyword">...</span>
    <span class="string">'MaxFuncEvals'</span>,1000,<span class="string">'Display'</span>,<span class="string">'final'</span>)
</pre><pre class="codeoutput">
x0 =

   -0.5883
    2.1832
   -0.1364
    0.1139
    1.0668
    0.0593
   -0.0956
   -0.8323
    0.2944
   -1.3362
    0.7143
    1.6236
   -0.6918
    0.8580


Data = 

  struct with fields:

    rank: 2
       A: [4&times;3 double]

 Iter  FuncEvals       F(X)          ||G(X)||/N        
------ --------- ---------------- ----------------
    29        67       0.28420491       0.00000001

out = 

  struct with fields:

             Params: [1&times;1 inputParser]
           ExitFlag: 0
    ExitDescription: 'Successful termination based on StopTol'
                  X: [14&times;1 double]
                  F: 0.2842
                  G: [14&times;1 double]
          FuncEvals: 67
              Iters: 29

</pre><p>Extracting the factors from the solution, we see that we have found a solution, since the the Euclidean norm of the difference between the matrix and the approximate solution is equal to the the <img src="examples_doc_eq12267211811494638899.png" alt="$k+1$" style="width:12px;height:5px;"> singular value of <img src="examples_doc_eq05147331747641807187.png" alt="$A$" style="width:4px;height:4px;"> [1, Theorem 2.5.3].</p><pre class="codeinput">[U,V] = example2_extract(4,3,2,out.X);
norm_diff = norm(Data.A-U*V')
sv = svd(Data.A);
sv_k_plus_1 = sv(k+1)
</pre><pre class="codeoutput">
norm_diff =

    0.7539


sv_k_plus_1 =

    0.7539

</pre><p><hr></p><h2 id="20">References</h2><p>[1] Golub, G. H. and Loan, C. F. V. (1996). <i>Matrix Computations</i>. Johns Hopkins University Press.</p><p class="footer"><br>
      Copyright 2019, National Technology &amp; Engineering Solutions of Sandia, LLC (NTESS).<br></p></div><!--
##### SOURCE BEGIN #####
%% Poblano Toolbox for MATLAB: Examples
% This section describes the examples provided with Poblano. These examples
% can be used as templates for other function/gradient M-files.
%%
%
% <html><hr></html>
%% Solving a Problem Using Poblano
% To solve a problem using Poblano, the following steps are performed: 
%
% * *Step 1: Create M-file for objective and gradient.* An M-file which
% takes a vector as input and provides a scalar function value and gradient
% vector (the same size as the input) must be provided to the Poblano
% optimizers. 
% * *Step 2: Call the optimizer.* One of the Poblano optimizers is called,
% taking an anonymous function handle to the function to be minimized, a
% starting point, and an optional set of optimizer parameters as inputs. 
%
% Poblano provides two example function/gradient M-files:
% 
% * |example1|: simple multivariate function
% * |example2|: more complicated function of a matrix variable
%%
%
% <html><hr></html>
%% Example 1: Multivariate Sum
%
% The following example is a simple multivariate function, $f_1 : R^N \to R$, 
% that can be minimized using Poblano:
%%
% 
% $$f_1(x) = \sum_{n=1}^N \sin(ax_i)$$
%%
% 
% $$\left(\nabla f_1(x)\right)_i = a \cos(ax_i)\; , \quad i=1,\dots,N$
%%
%
% where $a$ is a scalar parameter. 
%%
%
% Listed below are the contents of the |example1.m| M-file 
% distributed with the Poblano code. This is an example of a self-contained
% function requiring a vector of independent variables and an
% _optional_ scalar input parameter for $a$.
%
%     function [f,g]=example1(x,a)
%          if nargin < 2, a = 1; end
%          f = sum(sin(a*x));
%          g = a*cos(a*x);
%%
% 
% The following presents a call to |ncg| optimizer using the default
% parameters (see <B_ncg_docs.html NCG method> documentation for more
% details) along with the information displayed and output return by
% Poblano. By default, at each iteration Poblano displays the number of
% function evaluations (|FuncEvals|), the function value at the current
% iterate (|F(X)|), and the Euclidean norm of the scaled gradient at the
% current iterate (|||||G(X)||||||/N|, where |N| is the size of |X|) for
% each iteration. The output of Poblano optimizers is a Matlab structure
% containing the solution. See the <A3_poblano_out_docs.html Output
% Parameters> documentation for more details.
out = ncg(@(x) example1(x,3), pi/4)
%%
% The problem dimension, $N$, of |example1| is determined by the size of the
% initial guess. For example, to solve a problem with $N=10^6$, simply use
% an initial guess vector of size $N=10^6$ when calling the Poblano optimizer:
randn('state',0);
x0 = randn(1e6,1);
out = ncg(@(x) example1(x,3), x0, 'Display', 'final')
%% Example 2: Matrix Decomposition
%
% The following example is a more complicated function involving matrix
% variables. As the Poblano methods require scalar functions with vector
% inputs, variable matrices must be reshaped into vectors first. The
% problem in this example is to find a rank-$k$ decomposition, $UV^T$, of
% a $m \times n$ matrix, $A$, which minimizes the Frobenius norm of the fit
%%
%
% $$f_2 = \frac12\| A - UV^T \|_F^2$$
%%
%
% $$\nabla_U f_2 = -(A-UV^T)V$$
%%
%
% $$\nabla_V f_2 = -(A-UV^T)^T U$$
%%
%
% where $A \in R^{m \times n}$ is a matrix with rank $\geq k$, $U
% \in R^{m \times k}$, and $V \in R^{n \times k}$. This problem can be
% solved using Poblano by providing an M-file that computes the function
% and gradient shown above but that takes $U$ and $V$ as input in
% vectorized form.
%
% This problem can be solved using Poblano by providing an M-?le that
% computes the function and gradient shown above but that takes U and V as
% input in vectorized form.
%%
%
% Listed below are the contents of the |example2.m| M-file
% distributed with the Poblano code. Note that the input |Data| is
% required and is a structure containing the matrix to be decomposed, $A$,
% and the desired rank, $k$. This example also illustrates how the
% vectorized form of the factor matrices, $U$ and $V$, are converted to
% matrix form for the function and gradient computations.
%
%     function [f,g]=example2(x,Data)
%          % Data setup
%          [m,n] = size(Data.A);
%          k = Data.rank;
%          U = reshape(x(1:m*k),m,k);
%          V = reshape(x(m*k+1:m*k+n*k),n,k);
%
%          % Function value (residual)
%          AmUVt = Data.A-U*V';
%          f = 0.5*norm(AmUVt,'fro')^2;
%
%          % First derivatives computed in matrix form
%          g = zeros((m+n)*k,1);
%          g(1:m*k) = -reshape(AmUVt*V,m*k,1);
%          g(m*k+1:end) = -reshape(AmUVt'*U,n*k,1);
%%
%
% Included with Poblano are two helper functions and which can be used to
% generate problems instances along with starting points
% (|example2_init.m|) and extract the factors $U$ and $V$ from a solution
% vector (|example2_extract.m|). We show an example of their use below.
randn('state',0);
m = 4; n = 3; k = 2;
[x0,Data] = example2_init(m,n,k)
out = ncg(@(x) example2(x,Data), x0, 'RelFuncTol', 1e-16, 'StopTol', 1e-8, ...
    'MaxFuncEvals',1000,'Display','final')
%%
%
% Extracting the factors from the solution, we see that we have found a
% solution, since the the Euclidean norm of the difference between the
% matrix and the approximate solution is equal to the the $k+1$ singular
% value of $A$ [1, Theorem 2.5.3].
[U,V] = example2_extract(4,3,2,out.X);
norm_diff = norm(Data.A-U*V')
sv = svd(Data.A); 
sv_k_plus_1 = sv(k+1)
%%
%
% <html><hr></html>
%% References
%
% [1] Golub, G. H. and Loan, C. F. V. (1996). _Matrix Computations_. 
% Johns Hopkins University Press.
%

##### SOURCE END #####
--></body></html>